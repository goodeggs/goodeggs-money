// Generated by CoffeeScript 1.10.0
var BigNumber, Cents, arrayifySplat, isInt,
  slice = [].slice;

BigNumber = require('bignumber.js');

isInt = function(maybeInt) {
  return maybeInt % 1 === 0;
};

module.exports = Cents = Cents = (function() {
  var comparators, compareCentsFunction;

  compareCentsFunction = function(comparator) {
    return function(val, options) {
      var cents, otherCents;
      if (options == null) {
        options = {};
      }
      cents = this;
      if (options.strict == null) {
        options.strict = true;
      }
      if (options.strict) {
        return (val instanceof Cents) && comparator(cents, val);
      } else {
        otherCents = new Cents(val);
        return comparator(cents, otherCents);
      }
    };
  };

  comparators = {
    equals: function(cents, otherCents) {
      return cents.toNumber() === otherCents.toNumber();
    },
    lessThan: function(cents, otherCents) {
      return cents.toNumber() < otherCents.toNumber();
    },
    lessThanOrEqual: function(cents, otherCents) {
      return cents.toNumber() <= otherCents.toNumber();
    },
    greaterThan: function(cents, otherCents) {
      return cents.toNumber() > otherCents.toNumber();
    },
    greaterThanOrEqual: function(cents, otherCents) {
      return cents.toNumber() >= otherCents.toNumber();
    }
  };

  function Cents(value) {
    var ref;
    this.value = value;
    if (((ref = this.value) != null ? ref.toNumber : void 0) != null) {
      this.value = this.value.toNumber();
    }
    if (typeof this.value === 'string') {
      this.value = Number(this.value);
    }
    if (typeof this.value !== 'number') {
      throw new Error(this.value + " must be a Number");
    }
    if (isNaN(this.value)) {
      throw new Error(this.value + " must not be NaN");
    }
    if (!isInt(this.value)) {
      throw new Error(this.value + " must be an int");
    }
    if (this.value < 0) {
      throw new Error(this.value + " must not be negative");
    }
  }

  Cents.prototype.toBigNumber = function() {
    return new BigNumber(this.value);
  };

  Cents.prototype.toDollars = function() {
    return this.toBigNumber().dividedBy(100).toNumber();
  };

  Cents.prototype.toNumber = function() {
    return this.value;
  };

  Cents.prototype.plus = function(cents, arg) {
    var strict;
    strict = (arg != null ? arg : {
      strict: false
    }).strict;
    if (!strict) {
      cents = new Cents(cents);
    }
    return new Cents(this.toBigNumber().plus(cents.toNumber()));
  };

  Cents.prototype.minus = function(cents, arg) {
    var maxZero, ref, result, strict;
    ref = arg != null ? arg : {
      strict: false,
      maxZero: false
    }, strict = ref.strict, maxZero = ref.maxZero;
    if (!strict) {
      cents = new Cents(cents);
    }
    result = this.toBigNumber().minus(cents.toNumber()).toNumber();
    if (maxZero) {
      return new Cents(Math.max(0, result));
    } else {
      return new Cents(result);
    }
  };

  Cents.prototype.times = function(scalar, arg) {
    var result, transform;
    transform = (arg != null ? arg : {}).transform;
    result = this.toBigNumber().times(scalar);
    if (transform != null) {
      result = result[transform]();
    }
    return new Cents(result);
  };

  Cents.prototype.dividedBy = function(scalar, arg) {
    var result, transform;
    transform = (arg != null ? arg : {}).transform;
    result = this.toBigNumber().dividedBy(scalar);
    if (transform != null) {
      result = result[transform]();
    }
    return new Cents(result);
  };

  Cents.prototype.percent = function(percent, arg) {
    var scalar, transform;
    transform = (arg != null ? arg : {
      transform: 'round'
    }).transform;
    scalar = new BigNumber(percent).dividedBy(100).toNumber();
    return this.times(scalar, {
      transform: transform
    });
  };

  Cents.prototype.equals = compareCentsFunction(comparators.equals);

  Cents.prototype.lessThan = compareCentsFunction(comparators.lessThan);

  Cents.prototype.lessThanOrEqual = compareCentsFunction(comparators.lessThanOrEqual);

  Cents.prototype.greaterThan = compareCentsFunction(comparators.greaterThan);

  Cents.prototype.greaterThanOrEqual = compareCentsFunction(comparators.greaterThanOrEqual);

  Cents.prototype.is0 = function() {
    return this.equals(new Cents(0));
  };

  Cents.prototype.isnt0 = function() {
    return !this.is0();
  };

  Cents.prototype.toString = function() {
    return "$" + (new BigNumber(this.toDollars()).toFixed(2));
  };

  return Cents;

})();

Cents.prototype.lt = Cents.prototype.lessThan;

Cents.prototype.lte = Cents.prototype.lessThanOrEqual;

Cents.prototype.gt = Cents.prototype.greaterThan;

Cents.prototype.gte = Cents.prototype.greaterThanOrEqual;

Cents.isValid = function(maybeCents) {
  var error, threw;
  threw = false;
  try {
    new Cents(maybeCents);
  } catch (error) {
    threw = true;
  }
  return !threw;
};

Cents.isValidDollars = function(maybeDollars) {
  var error, threw;
  threw = false;
  try {
    Cents.fromDollars(maybeDollars);
  } catch (error) {
    threw = true;
  }
  return !threw;
};

Cents.fromDollars = function(dollars) {
  return new Cents(new BigNumber(dollars).times(100));
};

Cents.round = function(maybeInt) {
  if (!(maybeInt >= 0)) {
    throw new Error(maybeInt + " must be positive to round to cents");
  }
  return new Cents(new BigNumber(maybeInt).round());
};

arrayifySplat = function(splat, validator) {
  if (!(splat.length > 0)) {
    throw new Error('Expect at least one argument');
  }
  if (Array.isArray(splat[0])) {
    if (splat.length !== 1) {
      throw new Error('Expect a single array argument');
    }
    splat = splat[0];
  }
  if (validator != null) {
    splat.forEach(function(val) {
      if (!validator(val)) {
        throw new Error("Unexpected value " + val);
      }
    });
  }
  return splat;
};

Cents.min = function() {
  var cents, min;
  cents = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  cents = arrayifySplat(cents, Cents.isValid);
  cents = cents.map(function(cent) {
    return new Cents(cent).toNumber();
  });
  min = Math.min.apply(Math, cents);
  return new Cents(min);
};

Cents.max = function() {
  var cents, max;
  cents = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  cents = arrayifySplat(cents, Cents.isValid);
  cents = cents.map(function(cent) {
    return new Cents(cent).toNumber();
  });
  max = Math.max.apply(Math, cents);
  return new Cents(max);
};

Cents.sum = function() {
  var cents;
  cents = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  cents = arrayifySplat(cents, Cents.isValid);
  return cents.reduce((function(memo, val) {
    return memo.plus(val);
  }), new Cents(0));
};

Cents.sumDollars = function() {
  var dollars;
  dollars = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  dollars = arrayifySplat(dollars, Cents.isValidDollars);
  return dollars.reduce((function(memo, val) {
    return memo.plus(Cents.fromDollars(val));
  }), new Cents(0));
};
